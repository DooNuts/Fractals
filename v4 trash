import pygame
import time
import concurrent.futures
import numpy as np

width, height = 350, 350
iterations = 100
lim = 4
size = 32
zoom = 3
camX = -0.5
camY = -0.5

# zoom 300, camX -0.5, camY 0.61
# Linear = int(255 * m) % 255
# Sinusoidal = int(255 * (-math.cos(math.pi * m) + 1) / 2) % 255
# Square = int(255 * (m * m + 1)) % 255


def frac(pixels):
    x = pixels[0]
    y = pixels[1]
    ca = x / (width * zoom) + camX / zoom
    cb = y / (width * zoom) - camY / zoom
    a = ca
    b = cb
    n = 0
    while a * a + b * b < lim and n < iterations:
        ai = a * a - b * b
        bi = 2 * a * b

        a = ai + ca
        b = bi + cb
        n += 1
    m = n / iterations

    lin = int(255 * m) % 255
    r = lin
    g = lin
    b = lin
    return x, y, r, g, b


if __name__ == '__main__':
    win = (width, height)
    screen = pygame.display.set_mode(win)

    t1 = time.perf_counter()

    pixels = []
    for x in range(width):
        for y in range(height):
            pixels.append((x, y))

    with concurrent.futures.ThreadPoolExecutor() as e:
        fut = e.map(frac, pixels)

        for r in fut:
            screen.set_at((r[0], r[1]), (r[2], r[3], r[4]))




    pygame.display.update()

    t2 = time.perf_counter()
    print(t2 - t1)

    run = True
    while run:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
        keys = pygame.key.get_pressed()


# e.submit(frac, x, y, ratio, xOffset, yOffset, lim, iterations)
# e.submit(frac, x, y, ratio, xOffset, yOffset)
