import pygame
import time
import concurrent.futures
import numpy as np

width, height = 200, 200
iterations = 200
lim = 4
size = 4
zoom = 300

# zoom 300, camX -0.5, camY 0.61
# Linear = int(255 * m) % 255
# Sinusoidal = int(255 * (-math.cos(math.pi * m) + 1) / 2) % 255
# Square = int(255 * (m * m + 1)) % 255


def frac(pixels):
    x = pixels[0]
    y = pixels[1]
    ratio = pixels[2]
    xOffset = pixels[3]
    yOffset = pixels[4]
    a = (x * ratio) + xOffset
    b = (y * ratio) + yOffset
    ca = a
    cb = b
    n = 0
    while a * a + b * b < lim and n < iterations:
        ai = a * a - b * b
        bi = 2 * a * b

        a = ai + ca
        b = bi + cb
        n += 1
    m = n / iterations

    lin = int(255 * m) % 255
    r = lin
    g = lin
    b = lin
    return x, y, r, g, b


if __name__ == '__main__':
    win = (width, height)
    screen = pygame.display.set_mode(win)
    xAxis = size / zoom
    yAxis = xAxis * height / width
    camX = -0.5
    camY = 0.61
    t1 = time.perf_counter()

    xOffset0 = (-xAxis / 2) + camX
    yOffset0 = (-yAxis / 2) - camY
    ratio0 = xAxis / width

    pixels = []
    for x in range(width):
        for y in range(height):
            pixels.append((x, y, ratio0, xOffset0, yOffset0))

    with concurrent.futures.ProcessPoolExecutor() as e:
        fut = e.map(frac, pixels)

        for r in fut:
            screen.set_at((r[0], r[1]), (r[2], r[3], r[4]))




    pygame.display.update()

    t2 = time.perf_counter()
    print(t2 - t1)

    run = True
    while run:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
        keys = pygame.key.get_pressed()


# e.submit(frac, x, y, ratio, xOffset, yOffset, lim, iterations)
# e.submit(frac, x, y, ratio, xOffset, yOffset)
